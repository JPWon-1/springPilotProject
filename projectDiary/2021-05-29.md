# JWT 기반 세션관리
## corsFilter
* 이 곳에서 내 서버가 json을 통한 자바스크립트에도 응답을 허용하도록 설정해주었다.
```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true); // 내 서버가 응답을 할 때 json을 자바스크립트에서 처리할 수 있게 할지를 설정하는 것
        config.addAllowedOrigin("*"); // 모든 ip에 응답을 허용
        config.addAllowedHeader("*"); // 모든 header에 응답을 허용
        config.addAllowedMethod("*"); // post put delete...모든 메서드 허용
        source.registerCorsConfiguration("/api/**", config); // /api/**로 들어오는 모든 주소는 config 설정을 따라야함

        return new CorsFilter(source);
    }
}
```
## FilterConfig 에서는 FilterRegistrationBean을 통해 필터를 등록하고 이가 어느 시점에서 시작되는지 테스트 해보았다.

## security configure에서는 다음과 같이
```java
protected void configure(HttpSecurity http) throws Exception {
        // http.addFilterBefore(new MyFilter3(), SecurityContextPersistenceFilter.class);
        http.csrf().disable();
        http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()//세션을 사용하지 않는 정적인 서버로 만든다
        .addFilter(corsFilter) // 모든 요청은 이 필터를 타게 된다 //@CrossOrigin(인증 없을때 쓴다) <-> 인증이 있을때는 시큐리티 필터에 등록해야 한다.
        .formLogin().disable()
        .httpBasic().disable()
        .addFilter(new JwtAuthenticationFilter(authenticationManager()))//formLogin.disable해놓았기에 addFilter로 userNamePasswordAuthenticationFilter를 직접 활성화 시켜줌 
        .addFilter(new JwtAuthorizationFilter(authenticationManager(),memberRepository))
        .authorizeRequests()
            .antMatchers("/","/css/**","/scss/**","/img/**","/js/**","/h2-console/**").permitAll()
            .antMatchers("/api/v1/user/**").access("hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')")
            .antMatchers("/api/v1/manager/**").hasRole(Role.ADMIN.name())
            .antMatchers("/posts/write").access("hasRole('ROLE_USER') or hasRole('ROLE_ADMIN')")
            .anyRequest().permitAll();
    }
```
를 설정해주었다.
addFilter(JwtAuthenticationFilter)
addFilter(JwtAuthorizationFilter)를 추가해준것을 확인해야한다.

## JwtAuthenticationFilter 에서
attemptAuthentication ( 인증이 필요한 시도 올 경우 실행되는 함수 )이 실행되면 
아이디와 패스워드를 받아서 정상인지 확인을 한다.

그리고 authenticateionManager로 로그인 시도를 하면 PrincipalDetails를 호출하고 이 곳에서
loadUserByUsername이 자동으로 실행된다.

PrincipalDetails를 세션에 담은 후 JWT에 세션을 담아서 응답을 해준다.
JWT에 세션을 담는 과정은 attemptAuthentication이 아닌 successfulAuthentication에서 이루어진다.
이는 attemptAuthentication이 성공적으로 이루어지면 authentication을 반환해주는데 그 authResult의 principal을 받아 JWToken을 생성하고, 이를 request한 유저에게 response 해준다.

여기서 세션을 반환하는 이유는 유저의 권한을 spring security가 대신 해주기 때문에 편하게 사용하기 위해서인데, 권한을 사용안하면 굳이 할 필요 없다.

## doFilterInternal
인증이나 권한이 필요한 주소 요청이 올 경우 이 필터를 타게 된다.
jwtHeader가 있는지 확인하고 없으면 return;을 실행시켜 메서드를 중단시킨다.

있을 경우 헤더에서 JWT와 로그인 유저의 email을 decode해서 가져오고 JWT 서명을 통해 서명이 정상이면 Authentication 객체를 만들어 준다.
```java
Authentication authentication = 
                new UsernamePasswordAuthenticationToken(principalDetails, null, principalDetails.getAuthorities());

```
생성된 authentication을 Security 세션에 접근하여 저장해준다
```java
SecurityContextHolder.getContext().setAuthentication(authentication);
```
그리고 다음 필터체인을 호출해준다.
chain.doFilter(request,response)
### filterChain이란?
```md
FilterChain은 서블릿 컨테이너가 개발자에게 제공하는 개체로, 리소스에 대한 필터링 된 요청의 호출 체인에 대한보기를 제공합니다.
```
### 어떻게 작동하나
```md
chain.doFilter를 호출하면 요청 / 응답을 필터 체인의 다음 필터로 전달합니다. 호출하지 않으면 다음 필터 (아마 web.xml에 정의되어 있음)가 실행되지 않습니다.

방금 doFilter를 호출했다면 예, 끝없는 재귀와 스택 오버플로가 발생합니다. 그러나 다음 필터를 실행하도록 지시하는 filterChain 객체의 doFilter 메서드를 호출합니다.
```

## JwtProperties interface을 생성하여
토큰 생성에 필요한 값들을 생성해주었습니다. 이를 통해 오타나 하드코딩으로 생기는 문제를 줄일 수 있을 것이라 생각 했습니다.

